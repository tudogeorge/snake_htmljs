<html>
    <head>
        <title> Ssssnake </title>
        <script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.slim.min.js"></script>
        <script type="text/javascript">
            var theSnake;
        
            var oppositeDirs = {
                "U": "D",
                "D": "U",
                "L": "R",
                "R": "L"
            };
            //negative means coordinates increase, positive means decrease
            var forwardCoeffs = {
                "U": -1,
                "D": 1,
                "L": -1,
                "R": 1
            };
            //opposite of forwardCoeffs; I could've just used (-1 * forwardCoeffs[someDirection])
            var backwardCoeffs = {
                "U": 1,
                "D": -1,
                "L": 1,
                "R": -1
            };
            var bodyPartClasses = {
                "H": "head",
                "T": "tail",
                "N": "node"
            };
            var horizDirs = { "R": 1, "L": 1, "U": 0, "D": 0 };
            var vertDirs = { "R": 0, "L": 0, "U": 1, "D": 1 };
            
            var arrowKeys2NewDirs = {
                ArrowLeft:  "L",
                ArrowUp:    "U",
                ArrowRight: "R",
                ArrowDown:  "D"
            };
            
            var theFoodDispenser;
            
            //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive
            function getRandomIntInclusive(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive 
            }
            
            function FoodDispenser(rowCount, colCount) {
                this.rowCount = rowCount;
                this.colCount = colCount;
                this.foodItems = {};
                
                this.theBE = this.makeNewFoodItem();// new BigEgg(this, 3, 3);
            }
            FoodDispenser.prototype.constructor = FoodDispenser;
            FoodDispenser.prototype.checkCell = function(x, y) {
                var foodItm, cellID;
                if(foodItm = this.foodItems[cellID = "cell" + x + "_" + y]) {
                    foodItm.eatenBySnake();
                    delete this.foodItems[cellID];
                    this.makeNewFoodItem();
                }
            }
            FoodDispenser.prototype.makeNewFoodItem = function() {
                var maxY = this.rowCount + 1;
                var maxX = this.colCount + 1;
                
                var crtX, crtY;
                do {
                    crtX = getRandomIntInclusive(1, maxX);
                    crtY = getRandomIntInclusive(1, maxY);
                } while(!document.querySelector("#cell" + crtX + "_" + crtY + ":not(.body)"));
                this.theBE = new BigEgg(this, crtX, crtY);
                this.foodItems[this.theBE.cellName] = this.theBE;
            }
            
            function Point(x, y) {
                this.x = Math.trunc(x);
                this.y = Math.trunc(y);
            }
            Point.prototype.constructor = Point;
            
            function FoodItem(foodDispenser, x, y) {
                Point.call(this, x, y);
                this.foodDispenser = foodDispenser;
                this.cellName = "cell" + x + "_" + y;
                foodDispenser.foodItems[this.cellName] = this;
                
                //actionsWhenEaten items: {method, args}
                //method: a function to be called when the FoodItem is eaten
                //args: the arguments to be passed to the given method
                this.actionsWhenEaten = [];
                this.jqCell = $("#" + this.cellName);
            }
            FoodItem.prototype.constructor = FoodItem;
            FoodItem.prototype = Object.create(Point.prototype);
            FoodItem.prototype.eatenBySnake = function() {
                if(this.actionsWhenEaten) {
                    for(var i=0; i<this.actionsWhenEaten.length; i++) {
                        this.actionsWhenEaten[i].method.call(theSnake, this.actionsWhenEaten[i].args);
                    }
                }
            }
            
            function BigEgg(foodDispenser, x, y) {
                FoodItem.call(this, foodDispenser, x, y);
                this.actionsWhenEaten.push({
                    method: Snake.prototype.grow,
                    args: [5]
                })
                this.jqCell.addClass("BigEgg");
            }
            BigEgg.prototype.constructor = BigEgg;
            BigEgg.prototype = Object.create(FoodItem.prototype);
            
            //direction: L(eft), R(ight), U(p), D(own)
            //bodyPart: H(ead), B(ody), T(ail)
            function SnakeNode(x, y, oldDirection, direction, bodyPart) {
                Point.call(this, x, y);
                
                this.direction = direction;
                this.oldDirection = oldDirection;
                this.bodyPart = bodyPart;
            }
            SnakeNode.prototype.constructor = SnakeNode;
            SnakeNode.prototype = Object.create(Point.prototype);
            SnakeNode.prototype.getForwardCoeffs = function() {
                return forwardCoeffs[this.direction];
            }
            SnakeNode.prototype.getBackwardCoeffs = function() {
                return backwardCoeffs[this.direction];
            }
            
            function DLListItem(previous, data, next) {
                /*DLListItem*/ this.previous = previous;
                /*DLListItem*/ this.next = next;
                this.data = data;
            }
            DLListItem.prototype.constructor = DLListItem;
            
            function DLList(headData, tailData) {
                /*DLListItem*/ this.itmTail = new DLListItem(null, tailData);
                /*DLListItem*/ this.itmHead = new DLListItem(this.itmTail, headData, null);
                this.itmTail.next = this.itmHead;
            }
            DLList.prototype.constructor = DLList;
            DLList.prototype.insertBefore = function(dataToInsert, beforeThisItem) {
                var newNode = new DLListItem(beforeThisItem.previous, dataToInsert, beforeThisItem);
                if(beforeThisItem.previous)
                    beforeThisItem.previous.next = newNode;
                beforeThisItem.previous = newNode;
                return newNode;
            }
            DLList.prototype.remove = function(item) {
                if(item.previous)
                    item.previous.next = item.next;
                if(item.next)
                    item.next.previous = item.previous;
            }
            
            function Queue() {
                DLList.call(this, null, null);
            }
            Queue.prototype.constructor = Queue;
            Queue.prototype = Object.create(DLList.prototype);
            Queue.prototype.enqueue = function(data) {
                this.insertBefore(data, this.itmHead);
            }
            Queue.prototype.dequeue = function() {
                var result = this.itmTail.next;
                if(this.itmHead === result)
                    return null;
                
                this.remove(result);
                return result.data;
            }
            
            function Snake(rowCount, colCount) {
                var thisSnake = this;
                
                this.rowCount = rowCount;
                this.colCount = colCount;
                this.timeInterval = 300;
                this.intervalID;
                this.cntLeft2Grow = 0;
                this.nodes = new DLList(new SnakeNode(40 / 2 + 5, 15 / 2, "R", "R", "H"), new SnakeNode(40 / 2 - 5, 15 / 2, "R", "R", "T"));
                this.keyCommands = new Queue();
                
                this.draw();
                
                this.intervalID = setInterval(function() { thisSnake.advance(); }, this.timeInterval);
                
                document.onkeydown = function(event) {
                    var whereTo = arrowKeys2NewDirs[event.key];
                    if(whereTo) {
                        thisSnake.keyCommands.enqueue(whereTo);
                    }
                };
            }
            Snake.prototype.constructor = Snake;
            Snake.prototype.grow = function(howMuch) {
                this.cntLeft2Grow += howMuch;
            }
            Snake.prototype.draw = function() {
                var crtItm, nxtItm;
                var crtX = 0, crtY = 0;
                
                function setCrtItm(newCrtItm) {
                    crtItm = newCrtItm;
                    crtX = crtItm.data.x;
                    crtY = crtItm.data.y;
                    
                    nxtItm = crtItm ? crtItm.previous : null;
                }
                
                function nextCell() {
                    crtX += horizDirs[crtItm.data.direction] * backwardCoeffs[crtItm.data.direction];
                    crtY += vertDirs[crtItm.data.direction] * backwardCoeffs[crtItm.data.direction];
                }
                
                setCrtItm(this.nodes.itmHead);
                while(nxtItm) {
                    while(crtX != nxtItm.data.x || crtY != nxtItm.data.y) {
                        this.markCell(crtItm, crtX, crtY, "body");
                    this.markCell(crtItm, crtX, crtY);
                        nextCell();
                    }
                    setCrtItm(crtItm.previous);
                    this.markCell(crtItm, crtX, crtY, "body");
                    this.markCell(crtItm, crtX, crtY);
                    nextCell();
                }
            }
            Snake.prototype.getJQCell = function(x, y, snakeNode) {
                var crtX = x ? x : snakeNode.data.x;
                var crtY = y ? y : snakeNode.data.y;
                return $("#cell" + crtX + "_" + crtY);
            }
            Snake.prototype.markCell = function (crtItm, crtX, crtY, clear, preloadedJQCell) {
                var jqCell = preloadedJQCell ? preloadedJQCell : this.getJQCell(crtX, crtY, crtItm);
                if(clear) {
                    jqCell.attr("class", clear);
                    return jqCell;
                }
                var whatFn = jqCell.addClass;
                if(crtItm.data.x == crtX && crtItm.data.y == crtY) {
                    whatFn.call(jqCell, bodyPartClasses[crtItm.data.bodyPart]);
                    var dirClass = 
                        (crtItm == this.nodes.itmHead ? 
                            crtItm.data.direction :
                            (crtItm == this.nodes.itmTail ?
                                oppositeDirs[crtItm.data.direction] :
                                (crtItm.data.oldDirection + crtItm.data.direction)
                            )
                        );
                    whatFn.call(jqCell, "dir" + dirClass);
                }
                return jqCell;
            }
            Snake.prototype.gameOver = function(message) {
                clearInterval(this.intervalID);
                alert(message);
            }
            Snake.prototype.advance = function() {
                var crtNd = this.nodes.itmHead;
                var oldDirection = crtNd.data.direction;
                var newDirection = this.keyCommands.dequeue() || oldDirection;
                newDirection = oppositeDirs[newDirection] == oldDirection ? oldDirection : newDirection;
                
                crtNd.data.direction = newDirection;
                var newX, newY, oldX = crtNd.data.x, oldY = crtNd.data.y;
                function compNewXY() {
                    newX = crtNd.data.x + horizDirs[crtNd.data.direction] * forwardCoeffs[crtNd.data.direction];
                    newY = crtNd.data.y + vertDirs[crtNd.data.direction] * forwardCoeffs[crtNd.data.direction];
                }
                compNewXY();
                if(newX<1 || newX > this.colCount || newY<1 || newY > this.rowCount) {
                    this.gameOver("Game over, you left the playground.");
                } else {
                    var jqCell = this.getJQCell(newX, newY);
                    if(jqCell.hasClass("body")) {
                        this.gameOver("Game over, snake's riding itself now...");
                    } else {
                        theFoodDispenser.checkCell(newX, newY);
                        
                        this.markCell(crtNd, oldX, oldY, "body");
                        crtNd.data.x = newX;
                        crtNd.data.y = newY;
                        var newNode;
                        if(oldDirection != crtNd.data.direction) {
                            newNode = new SnakeNode(oldX, oldY, oldDirection, crtNd.data.direction, "N");
                            newNode = this.nodes.insertBefore(newNode, crtNd);
                            this.markCell(newNode, oldX, oldY);
                        }
                        this.markCell(crtNd, newX, newY, "body", jqCell);
                        this.markCell(crtNd, newX, newY, false, jqCell);
                    }
                }
                
                if(this.cntLeft2Grow) {
                    this.cntLeft2Grow--;
                    return;
                }
                crtNd = this.nodes.itmTail;
                oldX = crtNd.data.x;
                oldY = crtNd.data.y;
                compNewXY();
                if(crtNd.next.data.x == newX && crtNd.next.data.y == newY) {
                    crtNd.data.direction = crtNd.next.data.direction;
                    this.nodes.remove(crtNd.next);
                }
                this.markCell(crtNd, oldX, oldY, "none");
                crtNd.data.x = newX;
                crtNd.data.y = newY;
                this.markCell(crtNd, newX, newY);
            }
            
            $(document).ready(function() {
                var rowCount = 15;
                var colCount = 40;
                
                var jqTbl = $('<table cellspacing="0"></table>');
                var jqRw;
                for(var i=1; i<=rowCount; i++) {
                    jqRw = $("<tr></tr>");
                    for(var j=1; j<=colCount; j++) {
                        jqRw.append($('<td id="cell' + j + "_" + i + '"></td>'));
                    }
                    jqTbl.append(jqRw);
                }
                $("body").append(jqTbl);
                
                theFoodDispenser = new FoodDispenser(rowCount, colCount);
                theSnake = new Snake(rowCount, colCount);
            });
        </script>
        <style type="text/css">
            td {
                width: 15px;
                height: 15px;
                border: 1px solid black;
            }
            td .snakeBody {
                background-color: brown;
            }
            
            .body {
                background-color: black;
            }
            .body.dirR {
                border-radius: 0px 7px 7px 0px;
            }
            .body.dirL {
                border-radius: 7px 0px 0px 7px;
            }
            .body.dirU {
                border-radius: 7px 7px 0px 0px;
            }
            .body.dirD {
                border-radius: 0px 0px 7px 7px;
            }
            
            .body.dirRU, .body.dirDL {
                border-radius: 0px 0px 7px 0px;
            }
            .body.dirUR, .body.dirLD {
                border-radius: 7px 0px 0px 0px;
            }
            .body.dirRD, .body.dirUL {
                border-radius: 0px 7px 0px 0px;
            }
            .body.dirDR, .body.dirLU {
                border-radius: 0px 0px 0px 7px;
            }
            
            .BigEgg{
                border-radius: 5px;
                background-color: lightgoldenrodyellow;
                border-color: lightgoldenrodyellow;
            }
        </style>
    </head>
    <body>
    
    </body>
</html>
